//-----------------------------------------------------------------------------------
/*
	F's Plugins for VS2010/VS2012
*/
//-----------------------------------------------------------------------------------


#include "ColorSampler.h"
static const char FS_NAME_EDIT_DIALOG[] = { 0x66,0x75,0x6e,0x63,0x74,0x69,0x6f,0x6e,0x20,0x73,0x68,0x6f,0x77,0x43,0x6f,0x6c,0x6f,0x72,0x4e,0x61,0x6d,0x65,0x44,0x69,0x61,0x6c,0x6f,0x67,0x28,0x63,0x6f,0x75,0x6e,0x74,0x2c,0x20,0x6e,0x61,0x6d,0x65,0x73,0x41,0x72,0x72,0x61,0x79,0x29,0x20,0x7b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x76,0x61,0x72,0x20,0x77,0x69,0x6e,0x20,0x3d,0x20,0x6e,0x65,0x77,0x20,0x57,0x69,0x6e,0x64,0x6f,0x77,0x28,0x22,0x64,0x69,0x61,0x6c,0x6f,0x67,0x22,0x2c,0x20,0x22,0x45,0x64,0x69,0x74,0x20,0x43,0x6f,0x6c,0x6f,0x72,0x20,0x4e,0x61,0x6d,0x65,0x73,0x22,0x29,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x77,0x69,0x6e,0x2e,0x6f,0x72,0x69,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x22,0x63,0x6f,0x6c,0x75,0x6d,0x6e,0x22,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x77,0x69,0x6e,0x2e,0x61,0x6c,0x69,0x67,0x6e,0x43,0x68,0x69,0x6c,0x64,0x72,0x65,0x6e,0x20,0x3d,0x20,0x5b,0x22,0x66,0x69,0x6c,0x6c,0x22,0x2c,0x20,0x22,0x74,0x6f,0x70,0x22,0x5d,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x77,0x69,0x6e,0x2e,0x73,0x70,0x61,0x63,0x69,0x6e,0x67,0x20,0x3d,0x20,0x31,0x30,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x77,0x69,0x6e,0x2e,0x6d,0x61,0x72,0x67,0x69,0x6e,0x73,0x20,0x3d,0x20,0x31,0x36,0x3b,0x0d,0x0a,0x0d,0x0a,0x20,0x20,0x20,0x20,0x76,0x61,0x72,0x20,0x73,0x63,0x72,0x6f,0x6c,0x6c,0x47,0x72,0x6f,0x75,0x70,0x20,0x3d,0x20,0x77,0x69,0x6e,0x2e,0x61,0x64,0x64,0x28,0x22,0x67,0x72,0x6f,0x75,0x70,0x22,0x29,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x73,0x63,0x72,0x6f,0x6c,0x6c,0x47,0x72,0x6f,0x75,0x70,0x2e,0x6f,0x72,0x69,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x22,0x63,0x6f,0x6c,0x75,0x6d,0x6e,0x22,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x73,0x63,0x72,0x6f,0x6c,0x6c,0x47,0x72,0x6f,0x75,0x70,0x2e,0x61,0x6c,0x69,0x67,0x6e,0x43,0x68,0x69,0x6c,0x64,0x72,0x65,0x6e,0x20,0x3d,0x20,0x5b,0x22,0x6c,0x65,0x66,0x74,0x22,0x2c,0x20,0x22,0x74,0x6f,0x70,0x22,0x5d,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x73,0x63,0x72,0x6f,0x6c,0x6c,0x47,0x72,0x6f,0x75,0x70,0x2e,0x6d,0x61,0x78,0x69,0x6d,0x75,0x6d,0x53,0x69,0x7a,0x65,0x2e,0x68,0x65,0x69,0x67,0x68,0x74,0x20,0x3d,0x20,0x35,0x30,0x30,0x3b,0x0d,0x0a,0x0d,0x0a,0x20,0x20,0x20,0x20,0x76,0x61,0x72,0x20,0x70,0x61,0x6e,0x65,0x6c,0x20,0x3d,0x20,0x73,0x63,0x72,0x6f,0x6c,0x6c,0x47,0x72,0x6f,0x75,0x70,0x2e,0x61,0x64,0x64,0x28,0x22,0x70,0x61,0x6e,0x65,0x6c,0x22,0x2c,0x20,0x75,0x6e,0x64,0x65,0x66,0x69,0x6e,0x65,0x64,0x2c,0x20,0x22,0x41,0x63,0x74,0x69,0x76,0x65,0x20,0x43,0x6f,0x6c,0x6f,0x72,0x73,0x3a,0x20,0x22,0x20,0x2b,0x20,0x63,0x6f,0x75,0x6e,0x74,0x29,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x70,0x61,0x6e,0x65,0x6c,0x2e,0x61,0x6c,0x69,0x67,0x6e,0x43,0x68,0x69,0x6c,0x64,0x72,0x65,0x6e,0x20,0x3d,0x20,0x5b,0x22,0x6c,0x65,0x66,0x74,0x22,0x2c,0x20,0x22,0x74,0x6f,0x70,0x22,0x5d,0x3b,0x0d,0x0a,0x0d,0x0a,0x20,0x20,0x20,0x20,0x76,0x61,0x72,0x20,0x65,0x64,0x69,0x74,0x73,0x20,0x3d,0x20,0x5b,0x5d,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x66,0x6f,0x72,0x20,0x28,0x76,0x61,0x72,0x20,0x69,0x20,0x3d,0x20,0x30,0x3b,0x20,0x69,0x20,0x3c,0x20,0x63,0x6f,0x75,0x6e,0x74,0x3b,0x20,0x69,0x2b,0x2b,0x29,0x20,0x7b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x76,0x61,0x72,0x20,0x72,0x6f,0x77,0x20,0x3d,0x20,0x70,0x61,0x6e,0x65,0x6c,0x2e,0x61,0x64,0x64,0x28,0x22,0x67,0x72,0x6f,0x75,0x70,0x22,0x29,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x72,0x6f,0x77,0x2e,0x6f,0x72,0x69,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x22,0x68,0x6f,0x72,0x69,0x7a,0x6f,0x6e,0x74,0x61,0x6c,0x22,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x76,0x61,0x72,0x20,0x6c,0x62,0x6c,0x20,0x3d,0x20,0x72,0x6f,0x77,0x2e,0x61,0x64,0x64,0x28,0x22,0x73,0x74,0x61,0x74,0x69,0x63,0x74,0x65,0x78,0x74,0x22,0x2c,0x20,0x75,0x6e,0x64,0x65,0x66,0x69,0x6e,0x65,0x64,0x2c,0x20,0x28,0x69,0x20,0x2b,0x20,0x31,0x29,0x20,0x2b,0x20,0x22,0x3a,0x22,0x29,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x6c,0x62,0x6c,0x2e,0x63,0x68,0x61,0x72,0x61,0x63,0x74,0x65,0x72,0x73,0x20,0x3d,0x20,0x33,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x76,0x61,0x72,0x20,0x6e,0x61,0x6d,0x65,0x56,0x61,0x6c,0x20,0x3d,0x20,0x28,0x69,0x20,0x3c,0x20,0x6e,0x61,0x6d,0x65,0x73,0x41,0x72,0x72,0x61,0x79,0x2e,0x6c,0x65,0x6e,0x67,0x74,0x68,0x20,0x26,0x26,0x20,0x6e,0x61,0x6d,0x65,0x73,0x41,0x72,0x72,0x61,0x79,0x5b,0x69,0x5d,0x20,0x21,0x3d,0x3d,0x20,0x22,0x22,0x29,0x20,0x3f,0x20,0x6e,0x61,0x6d,0x65,0x73,0x41,0x72,0x72,0x61,0x79,0x5b,0x69,0x5d,0x20,0x3a,0x20,0x22,0x63,0x6f,0x6c,0x6f,0x72,0x22,0x20,0x2b,0x20,0x28,0x69,0x20,0x2b,0x20,0x31,0x29,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x76,0x61,0x72,0x20,0x65,0x74,0x20,0x3d,0x20,0x72,0x6f,0x77,0x2e,0x61,0x64,0x64,0x28,0x22,0x65,0x64,0x69,0x74,0x74,0x65,0x78,0x74,0x22,0x2c,0x20,0x75,0x6e,0x64,0x65,0x66,0x69,0x6e,0x65,0x64,0x2c,0x20,0x6e,0x61,0x6d,0x65,0x56,0x61,0x6c,0x29,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x65,0x74,0x2e,0x63,0x68,0x61,0x72,0x61,0x63,0x74,0x65,0x72,0x73,0x20,0x3d,0x20,0x32,0x35,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x65,0x64,0x69,0x74,0x73,0x2e,0x70,0x75,0x73,0x68,0x28,0x65,0x74,0x29,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x7d,0x0d,0x0a,0x0d,0x0a,0x20,0x20,0x20,0x20,0x76,0x61,0x72,0x20,0x62,0x74,0x6e,0x47,0x72,0x6f,0x75,0x70,0x20,0x3d,0x20,0x77,0x69,0x6e,0x2e,0x61,0x64,0x64,0x28,0x22,0x67,0x72,0x6f,0x75,0x70,0x22,0x29,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x62,0x74,0x6e,0x47,0x72,0x6f,0x75,0x70,0x2e,0x61,0x6c,0x69,0x67,0x6e,0x6d,0x65,0x6e,0x74,0x20,0x3d,0x20,0x22,0x72,0x69,0x67,0x68,0x74,0x22,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x77,0x69,0x6e,0x2e,0x61,0x64,0x64,0x28,0x22,0x62,0x75,0x74,0x74,0x6f,0x6e,0x22,0x2c,0x20,0x75,0x6e,0x64,0x65,0x66,0x69,0x6e,0x65,0x64,0x2c,0x20,0x22,0x4f,0x4b,0x22,0x2c,0x20,0x7b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x6e,0x61,0x6d,0x65,0x3a,0x20,0x22,0x6f,0x6b,0x22,0x0d,0x0a,0x20,0x20,0x20,0x20,0x7d,0x29,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x77,0x69,0x6e,0x2e,0x61,0x64,0x64,0x28,0x22,0x62,0x75,0x74,0x74,0x6f,0x6e,0x22,0x2c,0x20,0x75,0x6e,0x64,0x65,0x66,0x69,0x6e,0x65,0x64,0x2c,0x20,0x22,0x43,0x61,0x6e,0x63,0x65,0x6c,0x22,0x2c,0x20,0x7b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x6e,0x61,0x6d,0x65,0x3a,0x20,0x22,0x63,0x61,0x6e,0x63,0x65,0x6c,0x22,0x0d,0x0a,0x20,0x20,0x20,0x20,0x7d,0x29,0x3b,0x0d,0x0a,0x0d,0x0a,0x20,0x20,0x20,0x20,0x69,0x66,0x20,0x28,0x77,0x69,0x6e,0x2e,0x73,0x68,0x6f,0x77,0x28,0x29,0x20,0x3d,0x3d,0x20,0x31,0x29,0x20,0x7b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x76,0x61,0x72,0x20,0x72,0x65,0x73,0x75,0x6c,0x74,0x73,0x20,0x3d,0x20,0x5b,0x5d,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x66,0x6f,0x72,0x20,0x28,0x76,0x61,0x72,0x20,0x6a,0x20,0x3d,0x20,0x30,0x3b,0x20,0x6a,0x20,0x3c,0x20,0x63,0x6f,0x75,0x6e,0x74,0x3b,0x20,0x6a,0x2b,0x2b,0x29,0x20,0x7b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x76,0x61,0x72,0x20,0x74,0x20,0x3d,0x20,0x65,0x64,0x69,0x74,0x73,0x5b,0x6a,0x5d,0x2e,0x74,0x65,0x78,0x74,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x69,0x66,0x20,0x28,0x74,0x2e,0x72,0x65,0x70,0x6c,0x61,0x63,0x65,0x28,0x2f,0x5c,0x73,0x2f,0x67,0x2c,0x20,0x22,0x22,0x29,0x20,0x3d,0x3d,0x3d,0x20,0x22,0x22,0x29,0x20,0x7b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x74,0x20,0x3d,0x20,0x22,0x63,0x6f,0x6c,0x6f,0x72,0x22,0x20,0x2b,0x20,0x28,0x6a,0x20,0x2b,0x20,0x31,0x29,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x7d,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x72,0x65,0x73,0x75,0x6c,0x74,0x73,0x2e,0x70,0x75,0x73,0x68,0x28,0x74,0x29,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x7d,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x72,0x65,0x73,0x75,0x6c,0x74,0x73,0x2e,0x6a,0x6f,0x69,0x6e,0x28,0x22,0x7c,0x22,0x29,0x3b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x7d,0x0d,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x6e,0x75,0x6c,0x6c,0x3b,0x0d,0x0a,0x7d,0x0d,0x0a,0x2f,0x2a,0x0d,0x0a,0x76,0x61,0x72,0x20,0x74,0x65,0x73,0x74,0x43,0x6f,0x75,0x6e,0x74,0x20,0x3d,0x20,0x38,0x3b,0x0d,0x0a,0x76,0x61,0x72,0x20,0x74,0x65,0x73,0x74,0x4e,0x61,0x6d,0x65,0x73,0x20,0x3d,0x20,0x5b,0x22,0x52,0x65,0x64,0x22,0x2c,0x20,0x22,0x47,0x72,0x65,0x65,0x6e,0x22,0x2c,0x20,0x22,0x42,0x6c,0x75,0x65,0x22,0x2c,0x20,0x22,0x59,0x65,0x6c,0x6c,0x6f,0x77,0x22,0x2c,0x20,0x22,0x43,0x79,0x61,0x6e,0x22,0x2c,0x20,0x22,0x4d,0x61,0x67,0x65,0x6e,0x74,0x61,0x22,0x2c,0x20,0x22,0x57,0x68,0x69,0x74,0x65,0x22,0x2c,0x20,0x22,0x42,0x6c,0x61,0x63,0x6b,0x22,0x5d,0x3b,0x0d,0x0a,0x76,0x61,0x72,0x20,0x72,0x65,0x73,0x20,0x3d,0x20,0x73,0x68,0x6f,0x77,0x43,0x6f,0x6c,0x6f,0x72,0x4e,0x61,0x6d,0x65,0x44,0x69,0x61,0x6c,0x6f,0x67,0x28,0x74,0x65,0x73,0x74,0x43,0x6f,0x75,0x6e,0x74,0x2c,0x20,0x74,0x65,0x73,0x74,0x4e,0x61,0x6d,0x65,0x73,0x29,0x3b,0x0d,0x0a,0x69,0x66,0x20,0x28,0x72,0x65,0x73,0x20,0x21,0x3d,0x3d,0x20,0x6e,0x75,0x6c,0x6c,0x29,0x20,0x7b,0x0d,0x0a,0x20,0x20,0x20,0x20,0x61,0x6c,0x65,0x72,0x74,0x28,0x22,0x52,0x65,0x74,0x75,0x72,0x6e,0x65,0x64,0x20,0x74,0x6f,0x20,0x43,0x2b,0x2b,0x3a,0x5c,0x6e,0x22,0x20,0x2b,0x20,0x72,0x65,0x73,0x29,0x3b,0x0d,0x0a,0x7d,0x0d,0x0a,0x2a,0x2f,0x00 };
//-------------------------------------------------------------------------------------------------
//AfterEffextsにパラメータを通達する
//Param_Utils.hを参照のこと
static PF_Err ParamsSetup (
	PF_InData		*in_data,
	PF_OutData		*out_data,
	PF_ParamDef		*params[],
	PF_LayerDef		*output)
{
	PF_Err			err = PF_Err_NONE;
	NameInfo* infoP = NULL;
	AEGP_SuiteHandler suites(in_data->pica_basicP);
	A_HandleSize size = suites.HandleSuite1()->host_get_handle_size(in_data->sequence_data);
	if (in_data->sequence_data) {
		A_HandleSize size = suites.HandleSuite1()->host_get_handle_size(in_data->sequence_data);
		if (size >= sizeof(NameInfo)) {
			infoP = reinterpret_cast<NameInfo*>(suites.HandleSuite1()->host_lock_handle(in_data->sequence_data));
		}
	}
	NF_ParamsSetup cs(in_data, out_data);
	for (int i = 0; i < COLOR_TABLE_SIZE; i++) {
		std::string name;
		if (infoP && infoP->color_names[i][0] != '\0') {
			name = infoP->color_names[i];
		}
		else {
			name = std::string(STR_COLOR) + std::to_string(i + 1);
		}
		cs.AddColor(// color
			name.c_str(),
			{ 0xFF, (A_u_char)(i * 32), (A_u_char)(255 - i * 32), 0xFF },
			ID_COLOR(i),
			PF_PUI_NONE,
			PF_PUI_INVISIBLE
		);
	}
	cs.AddSlider(	// color count
		"colorCount",
		0,
		COLOR_TABLE_SIZE,
		0,
		COLOR_TABLE_SIZE,
		0,
		ID_COLOR_COUNT,
		PF_PUI_NONE,
		PF_PUI_INVISIBLE
	);
	cs.AddButton(	// button
		STR_GET_BTN,
		"get",
		ID_GET_BTN,
		PF_ParamFlag_SUPERVISE
	);
	cs.AddButton(	// button
		STR_NAME_EDIT_BTN,
		"edit",
		ID_NAME_EDIT_BTN,
		PF_ParamFlag_SUPERVISE
	);
	cs.AddButton(	// button
		STR_REF_BTN,
		"Sorry!",
		ID_REF_BTN,
		PF_ParamFlag_SUPERVISE
	);
	out_data->num_params = ID_NUM_PARAMS;

	//cs.Finalize();
	if (infoP) suites.HandleSuite1()->host_unlock_handle(in_data->sequence_data);
	return err;
}
//-------------------------------------------------------------------------------------------------
static PF_Err GetParams(NF_AE* ae, ParamInfo* infoP)
{
	PF_Err		err = PF_Err_NONE;

	for (int i = 0; i < COLOR_TABLE_SIZE; i++) {
		ERR(ae->GetCOLOR(ID_COLOR(i), &infoP->colors[i]));
	}
	ERR(ae->GetADD(ID_COLOR_COUNT, &infoP->color_count));
	return err;
}
//-------------------------------------------------------------------------------------------------
static PF_Err SetParams(NF_AE* ae, ParamInfo* infoP)
{
	PF_Err		err = PF_Err_NONE;

	for (int i = 0; i < COLOR_TABLE_SIZE; i++) {
		ERR(ae->SetCOLOR(ID_COLOR(i), infoP->colors[i]));
	}
	ERR(ae->SetADD(ID_COLOR_COUNT, infoP->color_count));
	return err;
}
// **************************************************************************************
// --- 保存用：ハンドルを「平坦なメモリ」にコピーする ---
static PF_Err
GetFlattenedSequenceData(
	PF_InData* in_data,
	PF_OutData* out_data)
{
	PF_Err			err = PF_Err_NONE;
	// Suiteの取得方法は既存の仕組みに従ってください
	AEGP_SuiteHandler suites(in_data->pica_basicP);

	if (in_data->sequence_data) {
		// 1. 保存用の新しいハンドルを作成
		PF_Handle flatH = suites.HandleSuite1()->host_new_handle(sizeof(NameInfo));
		if (flatH) {
			void* srcP = suites.HandleSuite1()->host_lock_handle(in_data->sequence_data);
			void* dstP = suites.HandleSuite1()->host_lock_handle(flatH);

			if (srcP && dstP) {
				// 2. データをコピー（NameInfoは固定長配列なのでmemcpyでOK）
				memcpy(dstP, srcP, sizeof(NameInfo));
			}

			// 3. 両方アンロックする（重要：disposeはしない！）
			if (srcP) suites.HandleSuite1()->host_unlock_handle(in_data->sequence_data);
			if (dstP) suites.HandleSuite1()->host_unlock_handle(flatH);

			// 4. AEにハンドルを託す
			out_data->sequence_data = flatH;
		}
		else {
			err = PF_Err_OUT_OF_MEMORY;
		}
	}
	return err;
}
// -------------------------------------------------------------------------------------------------
static PF_Err
SequenceSetup(PF_InData* in_data, PF_OutData* out_data)
{
	PF_Err err = PF_Err_NONE;
	AEGP_SuiteHandler suites(in_data->pica_basicP);

	PF_Handle seqH = suites.HandleSuite1()->host_new_handle(sizeof(NameInfo));
	if (seqH) {
		NameInfo* infoP = reinterpret_cast<NameInfo*>(suites.HandleSuite1()->host_lock_handle(seqH));
		if (infoP) {
			memset(infoP, 0, sizeof(NameInfo));
			infoP->color_count = 0;
			for (int i = 0; i < COLOR_TABLE_SIZE; i++) {
				sprintf_s(infoP->color_names[i], MAX_NAME_LEN, "Color%d", i + 1);
			}
			out_data->sequence_data = seqH;
			suites.HandleSuite1()->host_unlock_handle(seqH);
		}
		out_data->out_flags |= PF_OutFlag_SEND_UPDATE_PARAMS_UI;
	}
	return err;
}
// --- 【新規】復元用:平坦なデータを「ハンドル形式」に再び変換する ---
static PF_Err
SequenceResetup(
	PF_InData* in_data,
	PF_OutData* out_data)
{
	PF_Err err = PF_Err_NONE;
	AEGP_SuiteHandler suites(in_data->pica_basicP);

	if (in_data->sequence_data) {
		void* flatP = NULL;
		void* unflatP = NULL;
		PF_Handle newH = NULL;
		A_Boolean success = FALSE;
		A_HandleSize handle_size = 0;

		try {
			// 【修正1】保存されていた平坦データのサイズを取得
			handle_size = suites.HandleSuite1()->host_get_handle_size(in_data->sequence_data);
			
			// 【修正2】サイズが正しいか検証
			if (handle_size < sizeof(NameInfo)) {
				return PF_Err_INVALID_CALLBACK;
			}

			flatP = suites.HandleSuite1()->host_lock_handle(in_data->sequence_data);

			if (flatP) {
				// 【修正3】元のサイズを使用して新しいハンドルを作成
				newH = suites.HandleSuite1()->host_new_handle(handle_size);
				if (newH) {
					unflatP = suites.HandleSuite1()->host_lock_handle(newH);
					if (unflatP) {
						// 【修正4】実際のサイズでコピー
						memcpy(unflatP, flatP, handle_size);

						// 実行用データとしてセット
						out_data->sequence_data = newH;
						success = TRUE;
						
					}
				}
			}
		}
		catch (...) {
			// 例外が発生した場合のクリーンアップ
		}

		// アンロック処理
		if (unflatP) {
			suites.HandleSuite1()->host_unlock_handle(newH);
		}
		if (flatP) {
			suites.HandleSuite1()->host_unlock_handle(in_data->sequence_data);
		}

		// 失敗した場合はnewHを破棄
		if (!success && newH) {
			suites.HandleSuite1()->host_dispose_handle(newH);
		}
		if (success)
		{
			out_data->out_flags |= PF_OutFlag_SEND_UPDATE_PARAMS_UI;
		}
	}
	return err;
}
// --- 破棄時に呼ばれる ---
static PF_Err
SequenceSetdown(PF_InData* in_data, PF_OutData* out_data)
{
	AEGP_SuiteHandler suites(in_data->pica_basicP);
	if (in_data->sequence_data) {
		// ハンドルを解放する前にロックがすべて解除されている必要があります
		suites.HandleSuite1()->host_dispose_handle(in_data->sequence_data);
		out_data->sequence_data = NULL;
	}
	return PF_Err_NONE;
}
// **************************************************************************************
static PF_Err
GetColorsFromLayer(
	NF_AE* ae,
	ParamInfo* infoP,
	PF_LayerDef* layerP,
	PF_ParamDef* params[],
	PF_UserChangedParamExtra* extraP
)
{
	if (extraP->param_index == ID_GET_BTN) {
		PF_Err err = PF_Err_NONE;
		AEGP_PluginID my_id = 0;

		ae_global_dataH globH = reinterpret_cast<ae_global_dataH>(ae->in_data->global_data);
		if (globH && *globH) my_id = (*globH)->my_id;
		if (!my_id) ae->suitesP->UtilitySuite3()->AEGP_RegisterWithAEGP(NULL, NF_NAME, &my_id);

		AEGP_LayerH layerH = NULL;
		ae->suitesP->PFInterfaceSuite1()->AEGP_GetEffectLayer(ae->in_data->effect_ref, &layerH);

		if (layerH) {
			AEGP_LayerRenderOptionsH optionsH = NULL;
			ae->suitesP->LayerRenderOptionsSuite1()->AEGP_NewFromLayer(my_id, layerH, &optionsH);

			if (optionsH) {
				A_Time timeT = { ae->in_data->current_time, ae->in_data->time_scale };
				ae->suitesP->LayerRenderOptionsSuite1()->AEGP_SetTime(optionsH, timeT);

				AEGP_FrameReceiptH receiptH = NULL;
				err = ae->suitesP->RenderSuite5()->AEGP_RenderAndCheckoutLayerFrame(optionsH, NULL, NULL, &receiptH);

				if (!err && receiptH) {
					AEGP_WorldH worldH = NULL;
					ae->suitesP->RenderSuite4()->AEGP_GetReceiptWorld(receiptH, &worldH);

					if (worldH) {
						AEGP_WorldType world_type = AEGP_WorldType_NONE;
						ae->suitesP->WorldSuite3()->AEGP_GetType(worldH, &world_type);

						A_u_long row_bytes = 0;
						ae->suitesP->WorldSuite3()->AEGP_GetRowBytes(worldH, &row_bytes);
						A_long world_w = 0, world_h = 0;
						ae->suitesP->WorldSuite3()->AEGP_GetSize(worldH, &world_w, &world_h);

						PF_Pixel8* base_addr8 = NULL;
						PF_Pixel16* base_addr16 = NULL;
						PF_PixelFloat* base_addr32 = NULL;

						if (world_type == AEGP_WorldType_8) {
							ae->suitesP->WorldSuite3()->AEGP_GetBaseAddr8(worldH, &base_addr8);
						}
						else if (world_type == AEGP_WorldType_16) {
							ae->suitesP->WorldSuite3()->AEGP_GetBaseAddr16(worldH, &base_addr16);
						}
						else if (world_type == AEGP_WorldType_32) {
							ae->suitesP->WorldSuite3()->AEGP_GetBaseAddr32(worldH, &base_addr32);
						}

						if (base_addr8 || base_addr16 || base_addr32) {
							A_long num_masks = 0;
							ae->suitesP->MaskSuite5()->AEGP_GetLayerNumMasks(layerH, &num_masks);

							int color_idx = 0;
							for (A_long i = 0; i < num_masks && color_idx < COLOR_TABLE_SIZE; ++i) {
								AEGP_MaskRefH maskRefH = NULL;
								ae->suitesP->MaskSuite5()->AEGP_GetLayerMaskByIndex(layerH, i, &maskRefH);

								if (maskRefH) {
									AEGP_StreamRefH maskStreamH = NULL;
									ae->suitesP->StreamSuite5()->AEGP_GetNewMaskStream(my_id, maskRefH, AEGP_MaskStream_OUTLINE, &maskStreamH);

									if (maskStreamH) {
										AEGP_StreamValue2 val;
										AEFX_CLR_STRUCT(val);
										PF_Err stream_err = ae->suitesP->StreamSuite5()->AEGP_GetNewStreamValue(my_id, maskStreamH, AEGP_LTimeMode_LayerTime, &timeT, FALSE, &val);

										if (!stream_err && val.val.mask) {
											AEGP_MaskOutlineValH outlineH = val.val.mask;

											A_long num_segments = 0;
											ae->suitesP->MaskOutlineSuite3()->AEGP_GetMaskOutlineNumSegments(outlineH, &num_segments);

											A_long num_vertices = num_segments;
											AEGP_MaskVertex dummy_v;
											PF_Err v_err = ae->suitesP->MaskOutlineSuite3()->AEGP_GetMaskOutlineVertexInfo(outlineH, num_segments, &dummy_v);
											if (v_err == PF_Err_NONE) {
												num_vertices = num_segments + 1;
											}

											for (A_long v = 0; v < num_vertices && color_idx < COLOR_TABLE_SIZE; ++v) {
												AEGP_MaskVertex vertex;
												ae->suitesP->MaskOutlineSuite3()->AEGP_GetMaskOutlineVertexInfo(outlineH, v, &vertex);

												int x = static_cast<int>(vertex.x * world_w / ae->in_data->width);
												int y = static_cast<int>(vertex.y * world_h / ae->in_data->height);

												if (x >= 0 && x < world_w && y >= 0 && y < world_h) {
													PF_Pixel8 pixPP = { 0,0,0,0 };
													PF_Pixel8* pixP = &pixPP;

													if (world_type == AEGP_WorldType_8 && base_addr8) {
														pixP = reinterpret_cast<PF_Pixel8*>(reinterpret_cast<char*>(base_addr8) + (y * row_bytes) + (x * sizeof(PF_Pixel8)));
													}
													else if (world_type == AEGP_WorldType_16 && base_addr16) {
														PF_Pixel16* pixP16 = reinterpret_cast<PF_Pixel16*>(reinterpret_cast<char*>(base_addr16) + (y * row_bytes) + (x * sizeof(PF_Pixel16)));
														pixPP = NF_Pixel16To8(*pixP16);
													}
													else if (world_type == AEGP_WorldType_32 && base_addr32) {
														PF_PixelFloat* pixP32 = reinterpret_cast<PF_PixelFloat*>(reinterpret_cast<char*>(base_addr32) + (y * row_bytes) + (x * sizeof(PF_PixelFloat)));
														pixPP = NF_Pixel32To8(*pixP32);
													}

													infoP->colors[color_idx].alpha = pixP->alpha;
													infoP->colors[color_idx].red = pixP->red;
													infoP->colors[color_idx].green = pixP->green;
													infoP->colors[color_idx].blue = pixP->blue;
													color_idx++;
												}
											}
											
											// 【修正13】成功時のみ破棄
											ae->suitesP->StreamSuite5()->AEGP_DisposeStreamValue(&val);
										}
										// 【修正14】stream_errに関わらず常にDisposeStream
										ae->suitesP->StreamSuite5()->AEGP_DisposeStream(maskStreamH);
									}
									ae->suitesP->MaskSuite5()->AEGP_DisposeMask(maskRefH);
								}
							}
							
							infoP->color_count = color_idx;
							// 【修正15】SetParamsの呼び出しを削除（HandleChangedParam側で処理）
						}
					}
					ae->suitesP->RenderSuite4()->AEGP_CheckinFrame(receiptH);
				}
				ae->suitesP->LayerRenderOptionsSuite1()->AEGP_Dispose(optionsH);
			}
		}
		// 【修正16】UI更新フラグはHandleChangedParam側で設定
	}
	return PF_Err_NONE;
}
static PF_Err UpdateParameterUI(
	PF_InData* in_data,
	PF_OutData* out_data,
	PF_ParamDef* params[],
	PF_LayerDef* outputP
	)
{
	PF_Err				err = PF_Err_NONE;

	NameInfo* nameInfoP = NULL;
	AEGP_SuiteHandler* suitesP = NULL;
	ParamInfo info;
	A_long count = 0;
	AEFX_CLR_STRUCT(info);
	NF_AE ae;
	err = ae.UpdateParameterUI(in_data, out_data, params, outputP, ID_NUM_PARAMS);
	suitesP = ae.suitesP;
	GetParams(&ae, &info);
	
	if (in_data->sequence_data && suitesP) {
		nameInfoP = reinterpret_cast<NameInfo*>(suitesP->HandleSuite1()->host_lock_handle(in_data->sequence_data));
	}
	if (nameInfoP) {
		if (nameInfoP->color_count > 0) {
			char buf[64];
			ae.GetUIName(ID_COLOR01, buf);
			if (strcmp(buf, nameInfoP->color_names[0]) != 0) {
				PF_ParamDef def;
				AEFX_CLR_STRUCT(def);
				for (A_long i = 0; i < nameInfoP->color_count; i++) {
					ae.SetUIName(ID_COLOR(i), nameInfoP->color_names[i]);
				}
			}
			out_data->out_flags |= PF_OutFlag_SEND_UPDATE_PARAMS_UI;
		}
	}
	if (in_data->sequence_data && suitesP) {
		suitesP->HandleSuite1()->host_unlock_handle(in_data->sequence_data);
	}
	return err;
}
//-------------------------------------------------------------------------------------------------
static PF_Err
HandleChangedParam(
	PF_InData					*in_data,
	PF_OutData					*out_data,
	PF_ParamDef					*params[],
	PF_LayerDef					*outputP,
	PF_UserChangedParamExtra	*extraP)
{
	PF_Err				err					= PF_Err_NONE,
						err2				= PF_Err_NONE;
	NameInfo* nameInfoP = NULL;
	A_Boolean locked = FALSE;
	AEGP_SuiteHandler* suitesP = NULL;

	try{
		NF_AE ae;
		err =ae.HandleChangedParam(in_data,out_data,params,outputP,extraP,ID_NUM_PARAMS);
		suitesP = ae.suitesP;
		ParamInfo info;
		A_long count=0;
		AEFX_CLR_STRUCT(info);
		GetParams(&ae,&info);
		
		if (in_data->sequence_data && suitesP) {
			nameInfoP = reinterpret_cast<NameInfo*>(suitesP->HandleSuite1()->host_lock_handle(in_data->sequence_data));
			if (nameInfoP) {
				locked = TRUE;
			}
		}
		
		if (!err) {
			
			if (extraP->param_index == ID_GET_BTN && nameInfoP != NULL)
			{
				ERR(GetColorsFromLayer(&ae, &info, outputP, params, extraP));
				if(!err && nameInfoP !=NULL) {
					nameInfoP->color_count = info.color_count;
				}
				// 【修正17】GetColorsFromLayerから戻った後にSetParams呼び出し
				if (!err) {
					ERR(SetParams(&ae, &info));
				}
			}else if (extraP->param_index == ID_NAME_EDIT_BTN && nameInfoP!=NULL )
			{
				if (nameInfoP->color_count > 0) {
					std::string namesArrayStr = "[";
					for (int i = 0; i < nameInfoP->color_count; i++) {
						namesArrayStr += "'" + std::string(nameInfoP->color_names[i]) + "'";
						if (i < nameInfoP->color_count - 1) namesArrayStr += ",";
					}
					namesArrayStr += "]";

					// 3. 実行スクリプトの全貌を構築
					// 変数定義 + JSX本体 + 関数呼び出し
					std::string fullScript = "var _cnt = " + std::to_string(nameInfoP->color_count) + ";\r\n";
					fullScript += "var _names = " + namesArrayStr + ";\r\n";
					fullScript += std::string(FS_NAME_EDIT_DIALOG) + "\r\n"; // 16進数配列からの変換
					fullScript += "showColorNameDialog(_cnt, _names);";

					// 4. スクリプト実行
					AEGP_MemHandle resultMemH = NULL;
					ERR(suitesP->UtilitySuite5()->AEGP_ExecuteScript(ae.ae_plugin_idP->my_id, fullScript.c_str(), TRUE, &resultMemH, NULL));
					if (!err && resultMemH) {
						A_char* resultStr = NULL;
						suitesP->MemorySuite1()->AEGP_LockMemHandle(resultMemH, reinterpret_cast<void**>(&resultStr));

						if (resultStr && strlen(resultStr) > 0 && strcmp(resultStr, "null") != 0) {
							// 5. 戻り値をパース (例: "Red|Green|Blue")
							std::stringstream ss(resultStr);
							std::string segment;
							int idx = 0;

							while (std::getline(ss, segment, '|') && idx < nameInfoP->color_count) {
								// MAX_NAME_LENを超えないように安全にコピー
								if (segment.c_str() != NULL) 
								{
									strncpy(nameInfoP->color_names[idx], segment.c_str(), MAX_NAME_LEN - 1);
									nameInfoP->color_names[idx][MAX_NAME_LEN - 1] = '\0'; // 終端文字を保証
								}
								idx++;
							}

							// 2. 文字列を分割して保存
							if (nameInfoP->color_count > 0) {
								for(int i=0;i<nameInfoP->color_count;i++) {
									if (nameInfoP->color_names[i]!=NULL && nameInfoP->color_names[i][0] == '\0') {
										ae.SetUIName(ID_COLOR(i), nameInfoP->color_names[i]);
										/*
										def = *params[ID_COLOR(i)];
										PF_STRNNCPY(def.PF_DEF_NAME, nameInfoP->color_names[i], sizeof(def.PF_DEF_NAME));
										def.PF_DEF_NAME[sizeof(def.PF_DEF_NAME) - 1] = '\0'; // 念のため終端文字を保証
										ae.suitesP->ParamUtilsSuite3()->PF_UpdateParamUI(in_data->effect_ref, ID_COLOR(idx), &def);
										params[ID_COLOR(idx)]->uu.change_flags |= PF_ChangeFlag_CHANGED_VALUE;
										*/
									}
								}
								out_data->out_flags |= PF_OutFlag_SEND_UPDATE_PARAMS_UI;
							}
						}

						suitesP->MemorySuite1()->AEGP_UnlockMemHandle(resultMemH);
						suitesP->MemorySuite1()->AEGP_FreeMemHandle(resultMemH);
						out_data->out_flags |= PF_OutFlag_SEND_UPDATE_PARAMS_UI;
					}
				}
			}	

			if (in_data->appl_id != 'PrMr') {
				ERR(ae.GetNewEffectStreamAll());
				if (!err) {
					A_Boolean hide_themB[ID_NUM_PARAMS];
					for (A_long i = 0; i < ID_NUM_PARAMS; i++) hide_themB[i] = FALSE;
					for (A_long i = 0; i < COLOR_TABLE_SIZE; i++) hide_themB[ID_COLOR(i)] = TRUE;

					if (info.color_count > 0) {
						for (A_long i = 0; i < info.color_count; i++)hide_themB[ID_COLOR(i)] = FALSE;
					}
					hide_themB[ID_COLOR_COUNT] = TRUE;
					hide_themB[ID_GET_BTN] = FALSE;
					hide_themB[ID_NAME_EDIT_BTN] = FALSE;
	
					for (A_long i = 1; i < ID_NUM_PARAMS; i++) {
						ERR(ae.SetDynamicStreamFlag(i, AEGP_DynStreamFlag_HIDDEN, hide_themB[i]));
					}
				}
			}
			if (nameInfoP) {

				if (nameInfoP->color_count>0) {
					char buf[64];
					ae.GetUIName(ID_COLOR01, buf);
					if (strcmp(buf, nameInfoP->color_names[0]) != 0) {
						PF_ParamDef def;
						AEFX_CLR_STRUCT(def);
						for (A_long i = 0; i < nameInfoP->color_count; i++) {
							/*def = *params[ID_COLOR(i)];
							// 保存されている名前に書き換え
							if (nameInfoP->color_names[i] != NULL)
							{
								PF_STRNNCPY(def.PF_DEF_NAME, nameInfoP->color_names[i], sizeof(def.PF_DEF_NAME));
								def.PF_DEF_NAME[sizeof(def.PF_DEF_NAME) - 1] = '\0'; // 念のため終端文字を保証
								// UI を更新（これにより名前が反映される）
								ae.suitesP->ParamUtilsSuite3()->PF_UpdateParamUI(in_data->effect_ref, ID_COLOR(i), &def);
								params[ID_COLOR(i)]->uu.change_flags |= PF_ChangeFlag_CHANGED_VALUE;
							}*/
							ae.SetUIName(ID_COLOR(i), nameInfoP->color_names[i]);
						}
					}
					out_data->out_flags |= PF_OutFlag_SEND_UPDATE_PARAMS_UI;
				}
			}
			if (!err) {
				if (params != NULL) {
					PF_ParamDef* def;
					for (int i = 0; i < COLOR_TABLE_SIZE; i++) {
						def = NULL;
						def = params[ID_COLOR(i)];
						if (def != NULL) {
							def->uu.change_flags |= PF_ChangeFlag_CHANGED_VALUE;
						}
					}
				}
				out_data->out_flags |= PF_OutFlag_SEND_UPDATE_PARAMS_UI;
				//out_data->out_flags |= PF_OutFlag_FORCE_RERENDER;

			}
		}
		
		if (locked && in_data->sequence_data && suitesP) {
			suitesP->HandleSuite1()->host_unlock_handle(in_data->sequence_data);
			locked = FALSE;
		}

	}catch ( PF_Err & errP){
		err = errP;
		// 【修正18】host_unlock_handleに修正（host_lock_handleは間違い！）
		if (locked && in_data->sequence_data && suitesP) {
			suitesP->HandleSuite1()->host_unlock_handle(in_data->sequence_data);
			locked = FALSE;
		}
	}
	return err;
}
//-----------------------------------------------------------------------------------
static PF_Err
QueryDynamicFlags(	
	PF_InData		*in_data,	
	PF_OutData		*out_data,	
	PF_ParamDef		*params[],	
	void			*extra)	
{
	PF_Err 	err = PF_Err_NONE;
	// 全てのカラーパラメータに対して、UI変更を許可する
		// これにより、AEは必要に応じて ParamsSetup を再実行して名前を更新します
	if (params != NULL) {
		PF_ParamDef* def;
		for (int i = 0; i < COLOR_TABLE_SIZE; i++) {
			def = NULL;
			def = params[ID_COLOR(i)];
			if (def != NULL) {
				def->uu.change_flags |= PF_ChangeFlag_CHANGED_VALUE;
			}
		}
	}
	return err;
}


//-------------------------------------------------------------------------------------------------
static PF_Err 
	Exec (NF_AE*ae , ParamInfo *infoP)
{
	PF_Err	err = PF_Err_NONE;

	NameInfo* nameInfoP = reinterpret_cast<NameInfo*>(ae->suitesP->HandleSuite1()->host_lock_handle(
		ae->in_data->sequence_data));
	if(nameInfoP!=NULL)
	{
		PF_ParamDef* def;
		AEFX_CLR_STRUCT(def);
		if (nameInfoP->color_count > 0)
		{
			char buf[64];
			ae->GetUIName(ID_COLOR01,buf);
			if (strcmp(buf, nameInfoP->color_names[0])!=0)
			{
				for (A_long i = 0; i < nameInfoP->color_count; i++) {
					ae->SetUIName(ID_COLOR(i), nameInfoP->color_names[i]);
				}
			}
			ae->out_data->out_flags |= PF_OutFlag_SEND_UPDATE_PARAMS_UI;
		}
	}
	ae->suitesP->HandleSuite1()->host_unlock_handle(ae->in_data->sequence_data);

	//画面をコピー
	ERR(ae->CopyInToOut());

	
	return err;
}


//-----------------------------------------------------------------------------------
DllExport
PF_Err PluginDataEntryFunction2(
	PF_PluginDataPtr inPtr,
	PF_PluginDataCB2 inPluginDataCallBackPtr,
	SPBasicSuite* inSPBasicSuitePtr,
	const char* inHostName,
	const char* inHostVersion)
{
	PF_Err result = PF_Err_INVALID_CALLBACK;

	result = PF_REGISTER_EFFECT_EXT2(
		inPtr,
		inPluginDataCallBackPtr,
		NF_NAME, // Name
		NF_MATCHNAME, // Match Name
		NF_CATEGORY, // Category
		AE_RESERVED_INFO, // Reserved Info
		"EffectMain",	// Entry point
		"https://github.com/bryful");	// support URL

	return result;
}
DllExport	PF_Err
EffectMain(
	PF_Cmd			cmd,
	PF_InData* in_data,
	PF_OutData* out_data,
	PF_ParamDef* params[],
	PF_LayerDef* output,
	void* extraP)
{
	PF_Err			err = PF_Err_NONE,
					err2 = PF_Err_NONE;

	try
	{
		NF_AE ae;
		switch (cmd) {
		case PF_Cmd_ABOUT:
			err = ae.About(in_data, out_data, params, output);
			break;
		case PF_Cmd_GLOBAL_SETUP:
			err = ae.GlobalSetup(in_data, out_data, params, output);
			out_data->out_flags = NF_OUT_FLAGS;
			out_data->out_flags2 = NF_OUT_FLAGS2;
			break;
		case PF_Cmd_GLOBAL_SETDOWN:
			err = ae.GlobalSetdown(in_data);
			break;
		case PF_Cmd_PARAMS_SETUP:
			err = ParamsSetup(in_data, out_data, params, output);
			break;
		case PF_Cmd_SEQUENCE_SETUP:
			err = SequenceSetup(in_data, out_data);
			break;
		case PF_Cmd_SEQUENCE_SETDOWN:
			err = SequenceSetdown(in_data, out_data);
			break;
		case PF_Cmd_SEQUENCE_RESETUP:
			err = SequenceResetup(in_data, out_data);
			break;
		case PF_Cmd_RENDER:
			err = ae.Render(in_data, out_data, params, output, ID_NUM_PARAMS);
			if (!err) {
				ParamInfo info;
				AEFX_CLR_STRUCT(info);
				ERR(GetParams(&ae, &info));
				ERR(Exec(&ae, &info));
			}
			break;
		case PF_Cmd_SMART_PRE_RENDER:
			err = ae.PreRender(in_data, out_data, reinterpret_cast<PF_PreRenderExtra*>(extraP),sizeof(ParamInfo), ID_NUM_PARAMS);
			if (!err) {
				ParamInfo* infoP = reinterpret_cast<ParamInfo*>(ae.LockPreRenderData());
				if (infoP) {
					ae.SetHostPreRenderData();
					ERR(GetParams(&ae, infoP));
					ERR(ae.UnSetPreRenderData());
					ae.UnlockPreRenderData();
				}
				else {
					err = PF_Err_OUT_OF_MEMORY;
				}
			}
			break;
		case PF_Cmd_SMART_RENDER:
			err = ae.SmartRender(in_data, out_data, reinterpret_cast<PF_SmartRenderExtra*>(extraP), ID_NUM_PARAMS);
			if (!err) {
				ParamInfo* infoP = reinterpret_cast<ParamInfo*>(ae.LockPreRenderData());
				if (infoP) {
					ERR(Exec(&ae, infoP));
					ERR2(ae.UnsetSmartRender());
					ae.UnlockPreRenderData();
				}
				else {
					err = PF_Err_OUT_OF_MEMORY;
				}
			}
			break;
		case PF_Cmd_COMPLETELY_GENERAL:
		{
			AEGP_SuiteHandler suites(in_data->pica_basicP);

			suites.ANSICallbacksSuite1()->sprintf(out_data->return_msg,
				"%s",
				reinterpret_cast<A_char*>(extraP));
			break;
		}
		case PF_Cmd_DO_DIALOG:
		{
			//err = PopDialog(in_data,out_data,params,output);
			break;
		}
		case PF_Cmd_USER_CHANGED_PARAM:
		{
			err = HandleChangedParam(in_data,
				out_data,
				params,
				output,
				reinterpret_cast<PF_UserChangedParamExtra*>(extraP));

			break;
		}
		case PF_Cmd_UPDATE_PARAMS_UI:
		{
			err = UpdateParameterUI(in_data,
				out_data,
				params,
				output);
			break;
		}
		case PF_Cmd_QUERY_DYNAMIC_FLAGS:
			err = QueryDynamicFlags(in_data,
				out_data,
				params,
				reinterpret_cast<PF_UserChangedParamExtra*>(extraP));
			break;
		case  PF_Cmd_GET_FLATTENED_SEQUENCE_DATA:
			err = GetFlattenedSequenceData(in_data, out_data);
			break;
		case PF_Cmd_SEQUENCE_FLATTEN:
			err = GetFlattenedSequenceData(in_data, out_data);
			break;
		}
	}
	catch (PF_Err& thrown_err) {
		err = thrown_err;
	}
	if (err != PF_Err_NONE) {
		AEGP_SuiteHandler suites(in_data->pica_basicP);

		suites.ANSICallbacksSuite1()->sprintf(out_data->return_msg,
			"%d", cmd
			);
	}
	return err;
}

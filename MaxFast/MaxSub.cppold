#include "MaxFast.h"

typedef struct LineBuf {
    A_FpShort	level;
    A_long		index;
} LineBufInfo;

typedef struct MaxFastInfo {

	PF_InData* in_data;
    A_long			max;
    PF_Boolean		maxMinus;
	A_long          width;
	A_long		    widthTrue;
    A_long          height;
	PF_EffectWorld  *world;
    PF_PixelPtr     line;
	LineBuf*        forward;
    LineBuf*        backward;

}MaxFastInfo;

template <typename PixelType, typename ChannelType, ChannelType MaxChan>
static PF_Err
MaxMult(
    refconType refcon,
    A_long xL,
    A_long yL,
    PixelType* inP,
    PixelType* outP)
{
    PF_Err err = PF_Err_NONE;

    if (outP->alpha == 0) {
        outP->red = 0;
        outP->green = 0;
        outP->blue = 0;
        return err;
    }
    else if (outP->alpha >= MaxChan) {
        return err;
    }

    A_FpShort v = (A_FpShort)outP->alpha / MaxChan;
    outP->red = static_cast<ChannelType>((A_FpShort)outP->red * v);
    outP->green = static_cast<ChannelType>((A_FpShort)outP->green * v);
    outP->blue = static_cast<ChannelType>((A_FpShort)outP->blue * v);

    return PF_Err_NONE;
}

// 8bit用
static PF_Err
MaxMult8(
    refconType refcon,
    A_long xL,
    A_long yL,
    PF_Pixel8* inP,
    PF_Pixel8* outP)
{
    return MaxMult<PF_Pixel8, A_u_char, PF_MAX_CHAN8>(refcon, xL, yL, inP, outP);
}

// 16bit用
static PF_Err
MaxMult16(
    refconType refcon,
    A_long xL,
    A_long yL,
    PF_Pixel16* inP,
    PF_Pixel16* outP)
{
    return MaxMult<PF_Pixel16, A_u_short, PF_MAX_CHAN16>(refcon, xL, yL, inP, outP);
}

// 32bit用（浮動小数点）
static PF_Err
MaxMult32(
    refconType refcon,
    A_long xL,
    A_long yL,
    PF_PixelFloat* inP,
    PF_PixelFloat* outP)
{
    PF_Err err = PF_Err_NONE;

    if (outP->alpha <= 0.0f) {
        outP->red = 0.0f;
        outP->green = 0.0f;
        outP->blue = 0.0f;
        return err;
    }
    else if (outP->alpha == 1.0f) {
        return err;
    }

    outP->red *= outP->alpha;
    outP->green *= outP->alpha;
    outP->blue *= outP->alpha;

    return PF_Err_NONE;
}
//************************************************************************************
template <typename PixelType, typename ChannelType, ChannelType MaxChan>
static PF_Err
MaxUnMult(
    refconType refcon,
    A_long xL,
    A_long yL,
    PixelType* inP,
    PixelType* outP)
{
    PF_Err err = PF_Err_NONE;

    if (outP->alpha == 0) {
        outP->red = 0;
        outP->green = 0;
        outP->blue = 0;
        return err;
    }
    else if (outP->alpha >= MaxChan) {
        return err;
    }

    A_FpShort v = MaxChan /(A_FpShort)outP->alpha;
    outP->red = static_cast<ChannelType>((A_FpShort)outP->red * v);
    outP->green = static_cast<ChannelType>((A_FpShort)outP->green * v);
    outP->blue = static_cast<ChannelType>((A_FpShort)outP->blue * v);

    return PF_Err_NONE;
}
// 8bit用
static PF_Err
MaxUnMult8(
    refconType refcon,
    A_long xL,
    A_long yL,
    PF_Pixel8* inP,
    PF_Pixel8* outP)
{
    return MaxUnMult<PF_Pixel8, A_u_char, PF_MAX_CHAN8>(refcon, xL, yL, inP, outP);
}

// 16bit用
static PF_Err
MaxUnMult16(
    refconType refcon,
    A_long xL,
    A_long yL,
    PF_Pixel16* inP,
    PF_Pixel16* outP)
{
    return MaxUnMult<PF_Pixel16, A_u_short, PF_MAX_CHAN16>(refcon, xL, yL, inP, outP);
}

// 32bit用（浮動小数点）
static PF_Err
MaxUnMult32(
    refconType refcon,
    A_long xL,
    A_long yL,
    PF_PixelFloat* inP,
    PF_PixelFloat* outP)
{
    PF_Err err = PF_Err_NONE;

    if (outP->alpha <= 0.0f) {
        outP->red = 0.0f;
        outP->green = 0.0f;
        outP->blue = 0.0f;
        return err;
    }
    else if (outP->alpha == 1.0f) {
        return err;
    }
	PF_FpShort vv = 1.0f / outP->alpha;
    outP->red *= vv;
    outP->green *= vv;
    outP->blue *= vv;

    return PF_Err_NONE;
}
// ************************************************************************
static PF_Err
Max_SubH16(
    void* refconPV,
    A_long thread_idxL,
    A_long y,
    A_long itrtL)
{
    PF_Err err = PF_Err_NONE;
    MaxFastInfo* infoP = static_cast<MaxFastInfo*>(refconPV);
    int radius = infoP->max;
    if (radius <= 0) return err;

    PF_InData* in_data = infoP->in_data;
    A_long w = infoP->width;
    PF_Pixel16* outP = (PF_Pixel16*)infoP->world->data + (y * infoP->widthTrue);

    // 1. 半径が画像幅以上の場合は全画面最大値を計算（セーフティ）
    if (radius >= w) {
        PF_Pixel16 maax = outP[0];
        A_FpShort maaxV = ((A_FpShort)maax.red * 0.299) + ((A_FpShort)maax.green * 0.587) + ((A_FpShort)maax.blue * 0.114);
        for (A_long x = 1; x < w; x++) {
            A_FpShort v = ((A_FpShort)outP[x].red * 0.299) + ((A_FpShort)outP[x].green * 0.587) + ((A_FpShort)outP[x].blue * 0.114);
            if (v > maaxV) { maax = outP[x]; maaxV = v; }
        }
        for (A_long x = 0; x < w; x++) outP[x] = maax;
        return PF_Err_NONE;
    }

    // --- メモリ確保（※本来はスレッドごとに一度だけ確保に書き換えるべき箇所） ---

    A_long w2 = w + radius;
	w2 = (w2 + (16- w2 % 16)); // 16バイトアライメント
    PF_EffectWorld wld;
    AEFX_CLR_STRUCT(wld);
    ERR((*in_data->utils->new_world)(in_data->effect_ref, w2, 8, PF_NewWorldFlag_DEEP_PIXELS, &wld));
    if (err) return err;

    // 修正後のポインタ割り当て
    PF_Pixel16* line = (PF_Pixel16*)wld.data;
    A_FpShort* lineLevel = (A_FpShort*)(line + w2);
    LineBufInfo* forward = (LineBufInfo*)(lineLevel + w2);
    LineBufInfo* backward = forward + w2;
    for (A_long i = 0; i < w; i++) {
        line[i] = outP[i];
        lineLevel[i] = ((A_FpShort)line[i].red * 0.299) + ((A_FpShort)line[i].green * 0.587) + ((A_FpShort)line[i].blue * 0.114);
    }

    // 3. VHGアルゴリズム：累積最大値の構築 (O(W))
    int L = radius*2 + 1; 
    for (int b = 0; b < w; b += L) {
        int end = MIN(b + L, w);

        // 前方向
        forward[b].level = lineLevel[b];
        forward[b].index = b;
        for (int i = b + 1; i < end; i++) {
            if (forward[i - 1].level >= lineLevel[i]) {
                forward[i] = forward[i - 1];
            }
            else {
                forward[i].level = lineLevel[i];
                forward[i].index = i;
            }
        }

        // 後ろ方向
        backward[end - 1].level = lineLevel[end - 1];
        backward[end - 1].index = end - 1;
        for (int i = end - 2; i >= b; i--) {
            if (backward[i + 1].level >= lineLevel[i]) {
                backward[i] = backward[i + 1];
            }
            else {
                backward[i].level = lineLevel[i];
                backward[i].index = i;
            }
        }
    }

    // 4. 出力書き戻し：bループの外側で行う (O(W))
    for (int i = 0; i < w; i++) {
        int left = MAX(0, i - radius);
        int right = MIN(w - 1, i + radius);

        // 左端と右端が属するブロックを特定
        int left_block = left / L;
        int right_block = right / L;

        A_FpShort maxLevel = -FLT_MAX;
        int maxIndex = left;

        if (left_block == right_block) {
            // 同一ブロック内：線形探索
            for (int j = left; j <= right; j++) {
                if (lineLevel[j] > maxLevel) {
                    maxLevel = lineLevel[j];
                    maxIndex = j;
                }
            }
        }
        else {
            // 複数ブロックにまたがる場合

            // 1. 左端ブロックの backward[left]
            if (backward[left].level > maxLevel) {
                maxLevel = backward[left].level;
                maxIndex = backward[left].index;
            }

            // 2. 中間の完全に含まれるブロック（各ブロック全体の最大値）
            for (int b = left_block + 1; b < right_block; b++) {
                int block_start = b * L;
                // ブロック全体の最大値 = backward[block_start] と forward[MIN(block_start+L-1, w-1)] の比較
                int block_end = MIN(block_start + L - 1, w - 1);
                if (forward[block_end].level > maxLevel) {
                    maxLevel = forward[block_end].level;
                    maxIndex = forward[block_end].index;
                }
            }

            // 3. 右端ブロックの forward[right]
            if (forward[right].level > maxLevel) {
                maxLevel = forward[right].level;
                maxIndex = forward[right].index;
            }
        }

        outP[i] = line[maxIndex];
    }

    ERR((*in_data->utils->dispose_world)(in_data->effect_ref, &wld));
    return PF_Err_NONE;
}
// ************************************************************************

static PF_Err
Max_SubV16(
    void* refconPV,
    A_long thread_idxL,
    A_long x,
    A_long itrtL)
{
    PF_Err err = PF_Err_NONE;
    MaxFastInfo* infoP = static_cast<MaxFastInfo*>(refconPV);
    int radius = infoP->max;
    if (radius <= 0) return err;

    PF_InData* in_data = infoP->in_data;
    A_long h = infoP->height;
    A_long wt = infoP->widthTrue;

    // 1. 半径が画像高さ以上の場合は全列最大値を計算
    if (radius >= h) {
        PF_Pixel16 maax = *((PF_Pixel16*)infoP->world->data + x);
        A_FpShort maaxV = ((A_FpShort)maax.red * 0.299) + ((A_FpShort)maax.green * 0.587) + ((A_FpShort)maax.blue * 0.114);

        for (A_long y = 1; y < h; y++) {
            PF_Pixel16* p = (PF_Pixel16*)infoP->world->data + (y * wt + x);
            A_FpShort v = ((A_FpShort)p->red * 0.299) + ((A_FpShort)p->green * 0.587) + ((A_FpShort)p->blue * 0.114);
            if (v > maaxV) { maax = *p; maaxV = v; }
        }
        for (A_long y = 0; y < h; y++) {
            *((PF_Pixel16*)infoP->world->data + (y * wt + x)) = maax;
        }
        return PF_Err_NONE;
    }

    // 2. メモリ確保
    A_long h2 = h + radius;
    h2 = (h2 + (16 - h2 % 16));

    PF_EffectWorld wld;
    AEFX_CLR_STRUCT(wld);
    ERR((*in_data->utils->new_world)(in_data->effect_ref, h2, 8, PF_NewWorldFlag_DEEP_PIXELS, &wld));
    if (err) return err;

    PF_Pixel16* line = (PF_Pixel16*)wld.data;
    A_FpShort* lineLevel = (A_FpShort*)(line + h2);
    LineBufInfo* forward = (LineBufInfo*)(lineLevel + h2);
    LineBufInfo* backward = forward + h2;

    // 3. 列データをコピー
    for (A_long y = 0; y < h; y++) {
        line[y] = *((PF_Pixel16*)infoP->world->data + (y * wt + x));
        lineLevel[y] = ((A_FpShort)line[y].red * 0.299) + ((A_FpShort)line[y].green * 0.587) + ((A_FpShort)line[y].blue * 0.114);
    }

    // 4. VHGアルゴリズム
    int L = radius * 2 + 1;
    for (int b = 0; b < h; b += L) {
        int end = MIN(b + L, h);

        forward[b].level = lineLevel[b];
        forward[b].index = b;
        for (int i = b + 1; i < end; i++) {
            if (forward[i - 1].level >= lineLevel[i]) {
                forward[i] = forward[i - 1];
            }
            else {
                forward[i].level = lineLevel[i];
                forward[i].index = i;
            }
        }

        backward[end - 1].level = lineLevel[end - 1];
        backward[end - 1].index = end - 1;
        for (int i = end - 2; i >= b; i--) {
            if (backward[i + 1].level >= lineLevel[i]) {
                backward[i] = backward[i + 1];
            }
            else {
                backward[i].level = lineLevel[i];
                backward[i].index = i;
            }
        }
    }

    // 5. 出力
    for (int y = 0; y < h; y++) {
        int top = MAX(0, y - radius);
        int bottom = MIN(h - 1, y + radius);

        int top_block = top / L;
        int bottom_block = bottom / L;

        A_FpShort maxLevel = -FLT_MAX;
        int maxIndex = top;

        if (top_block == bottom_block) {
            for (int j = top; j <= bottom; j++) {
                if (lineLevel[j] > maxLevel) {
                    maxLevel = lineLevel[j];
                    maxIndex = j;
                }
            }
        }
        else {
            if (backward[top].level > maxLevel) {
                maxLevel = backward[top].level;
                maxIndex = backward[top].index;
            }
            for (int b = top_block + 1; b < bottom_block; b++) {
                int block_end = MIN(b * L + L - 1, h - 1);
                if (forward[block_end].level > maxLevel) {
                    maxLevel = forward[block_end].level;
                    maxIndex = forward[block_end].index;
                }
            }
            if (forward[bottom].level > maxLevel) {
                maxLevel = forward[bottom].level;
                maxIndex = forward[bottom].index;
            }
        }

        *((PF_Pixel16*)infoP->world->data + (y * wt + x)) = line[maxIndex];
    }

    ERR((*in_data->utils->dispose_world)(in_data->effect_ref, &wld));
    return PF_Err_NONE;
}
static PF_Err MaxFast_SubImpl(
	CFsAE* ae,
	A_long			max,
	PF_Boolean		maxMinus
)
{
    //ae->DisposeWorld
    PF_Err err = PF_Err_NONE;
	if (max == 0) return err;
	MaxFastInfo info;
	info.in_data = ae->in_data;
	info.max = max;
	info.maxMinus = maxMinus;
    info.world = ae->output;
    info.width = ae->out->width();
	info.widthTrue = ae->out->widthTrue();
    info.height = ae->out->height();

    if (!err) {
        PF_Iterate8Suite1* iterS = nullptr;
        AEFX_SuiteScoper<PF_Iterate8Suite1> iter_scope(
            ae->in_data,
            kPFIterate8Suite,
            kPFIterate8SuiteVersion1,
            ae->out_data
        );
        switch(ae->pixelFormat())
        {
        case PF_PixelFormat_ARGB32:
            ERR(ae->iterate8(&info, MaxMult8));
            ERR(ae->iterate8(&info, MaxUnMult8));
            break;
        case PF_PixelFormat_ARGB64:
            ERR(ae->iterate16(&info, MaxMult16));
            
                        

            ERR(iter_scope->iterate_generic(
                ae->output->height,     // iterationsL: 実行回数（＝行数）
                &info,                  // refconPV: ユーザー定義データ
                Max_SubH16              // fn_func: コールバック関数
            ));
            
            ERR(iter_scope->iterate_generic(
                    ae->output->width,           // iterationsL: 実行回数（＝行数）
                    &info,                    // refconPV: ユーザー定義データ
                    Max_SubV16    // fn_func: コールバック関数
                ));
                
            ERR(ae->iterate16(&info, MaxUnMult16));
            break;
        case PF_PixelFormat_ARGB128:
            ERR(ae->iterate32(&info, MaxMult32));
            //ERR(ae->iterate32(&info, MaxSub8));
            ERR(ae->iterate32(&info, MaxUnMult32));
            break;
        default:
            err = PF_Err_BAD_CALLBACK_PARAM;
            break;
        }
    }
    return err;
}


PF_Err MaxFast_Sub(
	CFsAE* ae,
	A_long			max,
	PF_Boolean		maxMinus
)
{
	return MaxFast_SubImpl(ae, max, maxMinus);
}
